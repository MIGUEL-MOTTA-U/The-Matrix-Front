name: Build and deploy Node.js app to Azure Web App - arswFront

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - uses: actions/checkout@v4

      - name: Install PNPM
        uses: pnpm/action-setup@v4
        with:
          version: 10.x

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '22.x'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build application
        run: pnpm build
        env:
          NODE_ENV: production

      - name: Debug build output structure
        run: |
          echo "Build directory structure:"
          ls -la build
          find build -type d | sort
          echo "Server build files:"
          find build/server -type f | sort
          echo "Client build files:"
          find build -path "*/public/build" -type d 2>/dev/null && find build -path "*/public/build" -type d -exec ls -la {} \; || echo "No public/build directory found"
          echo "App directory structure:"
          ls -la app || echo "No app directory at root"

      - name: Create optimized server for Remix
        run: |
          # Crear un servidor express optimizado para Remix
          cat > server.js << 'EOL'
          const path = require('path');
          const express = require('express');
          const compression = require('compression');
          const fs = require('fs');
          const { createRequestHandler } = require('@remix-run/express');

          const app = express();
          app.use(compression());

          // Health check for Azure
          app.get('/health', (req, res) => {
            res.status(200).send('OK');
          });

          // Debug route
          app.get('/debug', (req, res) => {
            const dirs = {
              cwd: process.cwd(),
              dirname: __dirname,
              contents: fs.readdirSync(__dirname),
              buildExists: fs.existsSync(path.join(__dirname, 'build')),
              buildContents: fs.existsSync(path.join(__dirname, 'build')) ? 
                fs.readdirSync(path.join(__dirname, 'build')) : [],
              buildServerExists: fs.existsSync(path.join(__dirname, 'build', 'server')),
              buildServerContents: fs.existsSync(path.join(__dirname, 'build', 'server')) ? 
                fs.readdirSync(path.join(__dirname, 'build', 'server')) : [],
              publicExists: fs.existsSync(path.join(__dirname, 'public')),
              publicContents: fs.existsSync(path.join(__dirname, 'public')) ? 
                fs.readdirSync(path.join(__dirname, 'public')) : []
            };
            res.json(dirs);
          });

          // Log server startup info
          console.log('Current directory:', __dirname);
          console.log('Files in directory:', fs.readdirSync(__dirname).join(', '));

          // Serve static assets
          app.use('/build', express.static('public/build', { immutable: true, maxAge: '1y' }));
          app.use(express.static('public', { maxAge: '1h' }));
          
          // Serve build assets (fallback)
          if (fs.existsSync(path.join(__dirname, 'build', 'client'))) {
            app.use('/build', express.static('build/client', { immutable: true, maxAge: '1y' }));
          }

          // Find and load the server build
          function locateBuildModule() {
            const possiblePaths = [
              path.join(__dirname, 'build', 'server', 'index.js'),
              path.join(__dirname, 'build', 'index.js'),
              path.join(__dirname, 'build', 'server'),
              path.join(__dirname, 'build')
            ];
            
            for (const buildPath of possiblePaths) {
              try {
                if (fs.existsSync(buildPath)) {
                  console.log(`Found build at: ${buildPath}`);
                  return require(buildPath);
                }
              } catch (err) {
                console.error(`Error trying to load build from ${buildPath}:`, err);
              }
            }
            
            throw new Error('Could not locate server build module');
          }

          // All requests not explicitly handled go to Remix
          let buildModule;
          try {
            buildModule = locateBuildModule();
            app.all('*', createRequestHandler({
              build: buildModule,
              getLoadContext: (req, res) => ({})
            }));
          } catch (err) {
            console.error('Failed to load build:', err);
            // Fallback to serving index.html if available
            app.get('*', (req, res) => {
              const indexPath = path.join(__dirname, 'public', 'index.html');
              if (fs.existsSync(indexPath)) {
                res.sendFile(indexPath);
              } else {
                res.status(500).send(`
                  <html>
                    <head><title>Server Error</title></head>
                    <body>
                      <h1>Server Configuration Error</h1>
                      <p>Could not load Remix application: ${err.message}</p>
                    </body>
                  </html>
                `);
              }
            });
          }

          const port = process.env.PORT || 8080;
          app.listen(port, () => {
            console.log(`Express server listening on port ${port}`);
          });
          EOL

          # Crear web.config para IIS
          cat > web.config << 'EOL'
          <?xml version="1.0" encoding="utf-8"?>
          <configuration>
            <system.webServer>
              <webSocket enabled="false" />
              <handlers>
                <add name="iisnode" path="server.js" verb="*" modules="iisnode"/>
              </handlers>
              <rewrite>
                <rules>
                  <rule name="StaticContent">
                    <action type="Rewrite" url="public{REQUEST_URI}"/>
                  </rule>
                  <rule name="DynamicContent">
                    <conditions>
                      <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="True"/>
                    </conditions>
                    <action type="Rewrite" url="server.js"/>
                  </rule>
                </rules>
              </rewrite>
              <iisnode
                nodeProcessCommandLine="node"
                watchedFiles="web.config;*.js"
                loggingEnabled="true"
                debuggingEnabled="true"
              />
            </system.webServer>
          </configuration>
          EOL

          # Package.json optimizado para Remix con Node.js 22
          cat > deploy-package.json << 'EOL'
          {
            "name": "the-matrix-front",
            "version": "1.0.0",
            "engines": { "node": "22.x" },
            "dependencies": {
              "@remix-run/express": "^2.16.0",
              "@remix-run/node": "^2.16.0",
              "@remix-run/react": "^2.16.0",
              "compression": "^1.7.4",
              "express": "^4.18.2",
              "react": "^18.2.0",
              "react-dom": "^18.2.0",
              "isbot": "^4.1.0"
            },
            "scripts": {
              "start": "node server.js"
            }
          }
          EOL

      - name: Create deployment package for Remix
        run: |
          # Crear estructura de despliegue
          mkdir -p deploy
          mkdir -p deploy/public
          
          # Copiar la carpeta build completa
          echo "Copying build folder to deployment package..."
          cp -r build deploy/ || echo "Failed to copy build directory"
          
          # Copiar la carpeta public si existe
          if [ -d "public" ]; then
            echo "Copying public folder to deployment package..."
            cp -r public/* deploy/public/ || echo "Failed to copy public directory"
          fi
          
          # Si hay archivos estáticos en build/client, copiarlos a public/build
          if [ -d "build/client" ]; then
            echo "Copying build/client assets to public/build..."
            mkdir -p deploy/public/build
            cp -r build/client/* deploy/public/build/ || echo "Failed to copy build/client to public/build"
          fi
          
          # Copiar servidor y configuración
          cp server.js deploy/
          cp web.config deploy/
          cp deploy-package.json deploy/package.json
          
          # Visualizar la estructura de despliegue
          echo "Deployment structure:"
          ls -la deploy
          echo "Public directory:"
          ls -la deploy/public || echo "No files in public directory!"
          echo "Build directory:"
          ls -la deploy/build || echo "No build directory in deployment package!"
          
          # Instalar dependencias de producción
          cd deploy && npm install --production

      - name: Zip artifact for deployment
        run: cd deploy && zip -r ../release.zip .

      - name: Upload artifact for deployment job
        uses: actions/upload-artifact@v4
        with:
          name: node-app
          path: release.zip

  deploy:
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: 'Production'
      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}
    
    steps:
      - name: Download artifact from build job
        uses: actions/download-artifact@v4
        with:
          name: node-app

      - name: Unzip artifact for deployment
        run: unzip release.zip
      
      # Paso para detener cualquier despliegue en curso
      - name: Stop ongoing deployments
        run: |
          # Extraer credenciales del perfil de publicación
          PUBLISH_PROFILE="${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_FRONTARSW }}"
          USERNAME=$(echo "$PUBLISH_PROFILE" | grep -o 'userName="[^"]*"' | cut -d'"' -f2 || echo "")
          PASSWORD=$(echo "$PUBLISH_PROFILE" | grep -o 'userPWD="[^"]*"' | cut -d'"' -f2 || echo "")
          
          # Intentar determinar la URL base de Kudu
          SCM_URL=$(echo "$PUBLISH_PROFILE" | grep -o 'publishUrl="[^"]*"' | cut -d'"' -f2 || echo "")
          
          if [ -n "$USERNAME" ] && [ -n "$PASSWORD" ]; then
            echo "Attempting to stop any ongoing deployments..."
            # Intentar detener directamente el sitio
            echo '<?xml version="1.0" encoding="utf-8"?><stop/>' > stop-site.xml
            
            # Usar la URL si está disponible, o intentar construirla
            if [ -n "$SCM_URL" ]; then
              KUDU_URL="https://$SCM_URL"
            else
              KUDU_URL="https://arswfront.scm.azurewebsites.net"
            fi
            
            curl -u "$USERNAME:$PASSWORD" \
              -H "Content-Type: application/xml" \
              --data-binary @stop-site.xml \
              "$KUDU_URL/api/stop" || true
            
            # Esperar unos segundos
            echo "Waiting for site to stop..."
            sleep 15
          else
            echo "Could not extract credentials from publish profile, skipping stop operation"
          fi
      
      # Primer intento de despliegue
      - name: Deploy to Azure Web App
        id: deploy-to-webapp
        uses: azure/webapps-deploy@v2
        with:
          app-name: 'arswFront'
          slot-name: 'Production'
          package: .
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_FRONTARSW }}
        continue-on-error: true
      
      # Si el primer intento falla, espera y reintentar
      - name: Retry deployment if failed
        if: steps.deploy-to-webapp.outcome != 'success'
        run: |
          echo "First deployment attempt failed, waiting 20 seconds before retry..."
          sleep 20
      
      # Segundo intento de despliegue
      - name: Second deployment attempt
        if: steps.deploy-to-webapp.outcome != 'success'
        id: deploy-retry
        uses: azure/webapps-deploy@v2
        with:
          app-name: 'arswFront'
          slot-name: 'Production'
          package: .
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_FRONTARSW }}
        continue-on-error: true
      
      # Último intento con reinicio del sitio
      - name: Final attempt with site restart
        if: steps.deploy-to-webapp.outcome != 'success' && steps.deploy-retry.outcome != 'success'
        run: |
          echo "Deployment attempts failed, trying one more time after site restart..."
          
          # Extraer credenciales del perfil de publicación
          PUBLISH_PROFILE="${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_FRONTARSW }}"
          USERNAME=$(echo "$PUBLISH_PROFILE" | grep -o 'userName="[^"]*"' | cut -d'"' -f2 || echo "")
          PASSWORD=$(echo "$PUBLISH_PROFILE" | grep -o 'userPWD="[^"]*"' | cut -d'"' -f2 || echo "")
          
          # Intentar determinar la URL base de Kudu
          SCM_URL=$(echo "$PUBLISH_PROFILE" | grep -o 'publishUrl="[^"]*"' | cut -d'"' -f2 || echo "")
          
          if [ -n "$USERNAME" ] && [ -n "$PASSWORD" ]; then
            # Crear archivos XML para los comandos
            echo '<?xml version="1.0" encoding="utf-8"?><stop/>' > stop-site.xml
            echo '<?xml version="1.0" encoding="utf-8"?><start/>' > start-site.xml
            
            # Usar la URL si está disponible, o intentar construirla
            if [ -n "$SCM_URL" ]; then
              KUDU_URL="https://$SCM_URL"
            else
              KUDU_URL="https://arswfront.scm.azurewebsites.net"
            fi
            
            # Ciclo completo de reinicio
            echo "Stopping the site..."
            curl -u "$USERNAME:$PASSWORD" \
              -H "Content-Type: application/xml" \
              --data-binary @stop-site.xml \
              "$KUDU_URL/api/stop" || true
            
            echo "Waiting 20 seconds..."
            sleep 20
            
            echo "Starting the site..."
            curl -u "$USERNAME:$PASSWORD" \
              -H "Content-Type: application/xml" \
              --data-binary @start-site.xml \
              "$KUDU_URL/api/start" || true
            
            echo "Waiting 10 seconds before final deployment attempt..."
            sleep 10
          else
            echo "Could not extract credentials from publish profile, skipping restart operation"
            sleep 30
          fi
      
      # Intento final de despliegue después del reinicio
      - name: Final deployment attempt
        if: steps.deploy-to-webapp.outcome != 'success' && steps.deploy-retry.outcome != 'success'
        uses: azure/webapps-deploy@v2
        with:
          app-name: 'arswFront'
          slot-name: 'Production'
          package: .
          publish-profile: ${{ secrets.AZUREAPPSERVICE_PUBLISHPROFILE_FRONTARSW }}